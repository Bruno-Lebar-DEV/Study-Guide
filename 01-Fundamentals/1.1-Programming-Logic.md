# ğŸ§  1.1 PROGRAMMING LOGIC AND COMPUTATIONAL MATHEMATICS

> *"The foundation of computational thinking: where mathematics meets algorithmic reasoning"*

---

## ğŸ¯ LEARNING OBJECTIVES

By the end of this section, you will be able to:
- **ğŸ” Apply logical reasoning** to solve computational problems
- **ğŸ§® Use mathematical concepts** in programming contexts
- **âš™ï¸ Design control structures** for complex program flow
- **ğŸ“Š Analyze logical operations** and their computational implications
- **ğŸ› ï¸ Implement mathematical algorithms** efficiently
- **ğŸ’¡ Think systematically** about problem decomposition

---

## ğŸ“š 1. FOUNDATIONS OF COMPUTATIONAL LOGIC

### ğŸ” **1.1 Propositional Logic**

#### **Basic Logical Operators**
- **AND (âˆ§):** `true âˆ§ true = true`
- **OR (âˆ¨):** `false âˆ¨ true = true`
- **NOT (Â¬):** `Â¬true = false`
- **XOR (âŠ•):** `true âŠ• true = false`
- **IMPLIES (â†’):** `false â†’ true = true`
- **IFF (â†”):** `true â†” true = true`

#### **Truth Tables and Logic Gates**
```
A | B | Aâˆ§B | Aâˆ¨B | AâŠ•B | Aâ†’B | Aâ†”B
--|---|-----|-----|-----|-----|-----
T | T |  T  |  T  |  F  |  T  |  T
T | F |  F  |  T  |  T  |  F  |  F
F | T |  F  |  T  |  T  |  T  |  F
F | F |  F  |  F  |  F  |  T  |  T
```

#### **Logical Equivalences**
- **De Morgan's Laws:**
  - `Â¬(A âˆ§ B) â‰¡ Â¬A âˆ¨ Â¬B`
  - `Â¬(A âˆ¨ B) â‰¡ Â¬A âˆ§ Â¬B`
- **Distributive Laws:**
  - `A âˆ§ (B âˆ¨ C) â‰¡ (A âˆ§ B) âˆ¨ (A âˆ§ C)`
  - `A âˆ¨ (B âˆ§ C) â‰¡ (A âˆ¨ B) âˆ§ (A âˆ¨ C)`

### ğŸ§® **1.2 Predicate Logic and Quantifiers**

#### **Universal Quantifier (âˆ€)**
- `âˆ€x P(x)`: "For all x, P(x) is true"
- Example: `âˆ€x (x > 0 â†’ xÂ² > 0)`

#### **Existential Quantifier (âˆƒ)**
- `âˆƒx P(x)`: "There exists an x such that P(x) is true"
- Example: `âˆƒx (xÂ² = 4)`

#### **Nested Quantifiers**
- `âˆ€x âˆƒy (x + y = 0)`: "For every x, there exists a y such that x + y = 0"
- Order matters: `âˆ€x âˆƒy P(x,y)` â‰  `âˆƒy âˆ€x P(x,y)`

---

## ğŸ”¢ 2. MATHEMATICAL FOUNDATIONS FOR PROGRAMMING

### ğŸ“ **2.1 Set Theory**

#### **Basic Set Operations**
- **Union:** `A âˆª B = {x | x âˆˆ A âˆ¨ x âˆˆ B}`
- **Intersection:** `A âˆ© B = {x | x âˆˆ A âˆ§ x âˆˆ B}`
- **Difference:** `A - B = {x | x âˆˆ A âˆ§ x âˆ‰ B}`
- **Complement:** `A' = {x | x âˆ‰ A}`
- **Cartesian Product:** `A Ã— B = {(a,b) | a âˆˆ A âˆ§ b âˆˆ B}`

#### **Set Properties**
- **Commutative:** `A âˆª B = B âˆª A`
- **Associative:** `(A âˆª B) âˆª C = A âˆª (B âˆª C)`
- **Distributive:** `A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)`
- **De Morgan's:** `(A âˆª B)' = A' âˆ© B'`

### ğŸ”¢ **2.2 Functions and Relations**

#### **Function Properties**
- **Injective (One-to-One):** `f(a) = f(b) â†’ a = b`
- **Surjective (Onto):** `âˆ€y âˆƒx (f(x) = y)`
- **Bijective:** Both injective and surjective
- **Inverse Function:** `fâ»Â¹(y) = x â†” f(x) = y`

#### **Relation Properties**
- **Reflexive:** `âˆ€x (xRx)`
- **Symmetric:** `âˆ€x,y (xRy â†’ yRx)`
- **Transitive:** `âˆ€x,y,z (xRy âˆ§ yRz â†’ xRz)`
- **Equivalence Relation:** Reflexive, symmetric, and transitive

### ğŸ“Š **2.3 Combinatorics and Probability**

#### **Counting Principles**
- **Multiplication Principle:** If event A can occur in m ways and event B in n ways, then both can occur in mÃ—n ways
- **Permutations:** `P(n,r) = n!/(n-r)!`
- **Combinations:** `C(n,r) = n!/(r!(n-r)!)`

#### **Probability Basics**
- **Sample Space (Î©):** Set of all possible outcomes
- **Event (E):** Subset of sample space
- **Probability:** `P(E) = |E|/|Î©|` (for uniform distribution)
- **Conditional Probability:** `P(A|B) = P(Aâˆ©B)/P(B)`
- **Bayes' Theorem:** `P(A|B) = P(B|A)P(A)/P(B)`

---

## âš™ï¸ 3. CONTROL STRUCTURES AND ALGORITHMIC THINKING

### ğŸ”„ **3.1 Sequential Control**

#### **Basic Sequential Operations**
```pseudocode
BEGIN
    INPUT value
    result â† value * 2
    OUTPUT result
END
```

#### **Assignment and State Changes**
- **Simple Assignment:** `x â† 5`
- **Compound Assignment:** `x â† x + 1`
- **Parallel Assignment:** `x, y â† y, x` (swap)

### ğŸ”€ **3.2 Conditional Control**

#### **Simple Conditional**
```pseudocode
IF condition THEN
    statement1
ELSE
    statement2
END IF
```

#### **Nested Conditionals**
```pseudocode
IF condition1 THEN
    IF condition2 THEN
        action1
    ELSE
        action2
    END IF
ELSE
    action3
END IF
```

#### **Multiple Conditions**
```pseudocode
IF condition1 THEN
    action1
ELSIF condition2 THEN
    action2
ELSIF condition3 THEN
    action3
ELSE
    default_action
END IF
```

### ğŸ” **3.3 Iterative Control**

#### **While Loop**
```pseudocode
WHILE condition DO
    statement
    update_condition
END WHILE
```

#### **For Loop**
```pseudocode
FOR i â† start TO end STEP increment DO
    statement(i)
END FOR
```

#### **Do-While Loop**
```pseudocode
DO
    statement
    update_condition
WHILE condition
```

#### **Nested Loops**
```pseudocode
FOR i â† 1 TO n DO
    FOR j â† 1 TO m DO
        process(i, j)
    END FOR
END FOR
```

---

## ğŸ§® 4. MATHEMATICAL ALGORITHMS AND COMPUTATIONS

### ğŸ”¢ **4.1 Number Theory Algorithms**

#### **Greatest Common Divisor (Euclidean Algorithm)**
```pseudocode
FUNCTION gcd(a, b)
    WHILE b â‰  0 DO
        temp â† b
        b â† a MOD b
        a â† temp
    END WHILE
    RETURN a
END FUNCTION
```

#### **Least Common Multiple**
```pseudocode
FUNCTION lcm(a, b)
    RETURN (a * b) / gcd(a, b)
END FUNCTION
```

#### **Prime Number Detection**
```pseudocode
FUNCTION isPrime(n)
    IF n â‰¤ 1 THEN RETURN false
    IF n â‰¤ 3 THEN RETURN true
    IF n MOD 2 = 0 OR n MOD 3 = 0 THEN RETURN false
    
    i â† 5
    WHILE i * i â‰¤ n DO
        IF n MOD i = 0 OR n MOD (i + 2) = 0 THEN
            RETURN false
        END IF
        i â† i + 6
    END WHILE
    RETURN true
END FUNCTION
```

### ğŸ“ **4.2 Linear Algebra Computations**

#### **Matrix Operations**
```pseudocode
FUNCTION matrixMultiply(A, B)
    rows_A â† number of rows in A
    cols_A â† number of columns in A
    cols_B â† number of columns in B
    
    CREATE matrix C[rows_A][cols_B]
    
    FOR i â† 0 TO rows_A - 1 DO
        FOR j â† 0 TO cols_B - 1 DO
            C[i][j] â† 0
            FOR k â† 0 TO cols_A - 1 DO
                C[i][j] â† C[i][j] + A[i][k] * B[k][j]
            END FOR
        END FOR
    END FOR
    
    RETURN C
END FUNCTION
```

#### **Vector Operations**
```pseudocode
FUNCTION dotProduct(v1, v2)
    result â† 0
    FOR i â† 0 TO length(v1) - 1 DO
        result â† result + v1[i] * v2[i]
    END FOR
    RETURN result
END FUNCTION

FUNCTION vectorMagnitude(v)
    sum â† 0
    FOR i â† 0 TO length(v) - 1 DO
        sum â† sum + v[i]Â²
    END FOR
    RETURN sqrt(sum)
END FUNCTION
```

### ğŸ“Š **4.3 Statistical Computations**

#### **Basic Statistics**
```pseudocode
FUNCTION mean(data)
    sum â† 0
    FOR each value in data DO
        sum â† sum + value
    END FOR
    RETURN sum / length(data)
END FUNCTION

FUNCTION variance(data)
    m â† mean(data)
    sum â† 0
    FOR each value in data DO
        sum â† sum + (value - m)Â²
    END FOR
    RETURN sum / length(data)
END FUNCTION

FUNCTION standardDeviation(data)
    RETURN sqrt(variance(data))
END FUNCTION
```

---

## ğŸ› ï¸ 5. PROBLEM-SOLVING METHODOLOGIES

### ğŸ¯ **5.1 Problem Analysis Framework**

#### **Step 1: Problem Understanding**
1. **Read carefully** and identify key information
2. **Clarify ambiguities** and ask questions
3. **Identify constraints** and limitations
4. **Understand expected output** format and requirements

#### **Step 2: Problem Decomposition**
1. **Break down** complex problems into smaller subproblems
2. **Identify patterns** and recurring themes
3. **Establish relationships** between different parts
4. **Prioritize** subproblems by complexity and dependencies

#### **Step 3: Solution Design**
1. **Choose appropriate algorithms** and data structures
2. **Design step-by-step approach** (pseudocode)
3. **Consider edge cases** and error handling
4. **Evaluate complexity** and optimize if necessary

### ğŸ” **5.2 Algorithmic Design Patterns**

#### **Brute Force**
- **Approach:** Try all possible solutions
- **When to use:** Small problem size, simple requirements
- **Example:** Finding maximum element in array

#### **Divide and Conquer**
- **Approach:** Break problem into smaller subproblems
- **When to use:** Problem can be naturally divided
- **Example:** Binary search, merge sort

#### **Greedy Algorithm**
- **Approach:** Make locally optimal choices
- **When to use:** Local optimum leads to global optimum
- **Example:** Minimum spanning tree, activity selection

#### **Dynamic Programming**
- **Approach:** Store solutions to subproblems
- **When to use:** Overlapping subproblems, optimal substructure
- **Example:** Fibonacci sequence, knapsack problem

---

## ğŸ† 6. PRACTICAL EXERCISES AND APPLICATIONS

### ğŸ’» **6.1 Logic Exercises**

#### **Exercise 1: Logic Circuit Simulation**
Design a program that simulates logic gates and evaluates complex boolean expressions.

#### **Exercise 2: Truth Table Generator**
Create a program that generates truth tables for any given boolean expression.

#### **Exercise 3: Logical Inference Engine**
Implement a simple inference engine that can derive new facts from given premises.

### ğŸ§® **6.2 Mathematical Programming**

#### **Exercise 4: Number Theory Calculator**
Implement functions for GCD, LCM, prime factorization, and modular arithmetic.

#### **Exercise 5: Matrix Calculator**
Create a comprehensive matrix calculator supporting addition, multiplication, determinant, and inverse operations.

#### **Exercise 6: Statistical Analysis Tool**
Build a program that performs basic statistical analysis on datasets.

### âš™ï¸ **6.3 Algorithm Implementation**

#### **Exercise 7: Sorting Algorithm Comparison**
Implement and compare different sorting algorithms (bubble, selection, insertion, merge, quick).

#### **Exercise 8: Search Algorithm Analysis**
Implement linear search, binary search, and analyze their performance on different datasets.

#### **Exercise 9: Recursive Problem Solving**
Solve problems using recursion: factorial, Fibonacci, Tower of Hanoi, tree traversal.

---

## ğŸ“ˆ 7. COMPLEXITY ANALYSIS INTRODUCTION

### â±ï¸ **7.1 Time Complexity Basics**

#### **Big O Notation**
- **O(1):** Constant time
- **O(log n):** Logarithmic time
- **O(n):** Linear time
- **O(n log n):** Linearithmic time
- **O(nÂ²):** Quadratic time
- **O(2â¿):** Exponential time

#### **Common Complexity Examples**
```pseudocode
// O(1) - Constant
FUNCTION getFirstElement(array)
    RETURN array[0]
END FUNCTION

// O(n) - Linear
FUNCTION findMax(array)
    max â† array[0]
    FOR i â† 1 TO length(array) - 1 DO
        IF array[i] > max THEN
            max â† array[i]
        END IF
    END FOR
    RETURN max
END FUNCTION

// O(nÂ²) - Quadratic
FUNCTION bubbleSort(array)
    n â† length(array)
    FOR i â† 0 TO n - 2 DO
        FOR j â† 0 TO n - i - 2 DO
            IF array[j] > array[j + 1] THEN
                swap(array[j], array[j + 1])
            END IF
        END FOR
    END FOR
END FUNCTION
```

### ğŸ’¾ **7.2 Space Complexity**

#### **Space Complexity Categories**
- **Auxiliary Space:** Extra space used by algorithm
- **Space Complexity:** Total space used (input + auxiliary)
- **In-place Algorithms:** O(1) auxiliary space
- **Out-of-place Algorithms:** O(n) or more auxiliary space

---

## ğŸ”— 8. CONNECTIONS TO ADVANCED TOPICS

### ğŸŒ **8.1 Applications in Software Engineering**
- **Database Query Optimization:** Using logical operations and set theory
- **Compiler Design:** Parsing and logical analysis
- **Artificial Intelligence:** Logical reasoning and inference
- **Computer Graphics:** Linear algebra and geometric transformations

### ğŸ”® **8.2 Preparation for Advanced Studies**
- **Discrete Mathematics:** Foundation for theoretical computer science
- **Algorithm Design:** Advanced algorithmic paradigms
- **Data Structures:** Complex data organization and manipulation
- **Machine Learning:** Statistical foundations and optimization

---

## ğŸ“š 9. RESOURCES AND FURTHER READING

### ğŸ“– **Essential Books**
- "Discrete Mathematics and Its Applications" by Kenneth Rosen
- "Mathematical Reasoning: Writing and Proof" by Ted Sundstrom
- "How to Prove It" by Daniel Velleman
- "Mathematical Thinking" by Keith Devlin

### ğŸ¥ **Online Resources**
- Khan Academy: Discrete Mathematics
- MIT OpenCourseWare: Mathematics for Computer Science
- Coursera: Mathematical Thinking in Computer Science
- edX: Introduction to Logic and Reasoning

### ğŸ› ï¸ **Practice Platforms**
- Project Euler (mathematical programming problems)
- HackerRank (logic and mathematics sections)
- Brilliant.org (interactive problem solving)
- CodeWars (kata challenges)

---

## âœ… 10. SELF-ASSESSMENT CHECKLIST

### ğŸ¯ **Logic and Reasoning**
- [ ] Can construct and evaluate truth tables
- [ ] Understand logical equivalences and inference rules
- [ ] Can apply De Morgan's laws and other logical transformations
- [ ] Understand predicate logic and quantifiers

### ğŸ§® **Mathematical Foundations**
- [ ] Comfortable with set operations and properties
- [ ] Understand functions, relations, and their properties
- [ ] Can apply basic combinatorics and probability
- [ ] Familiar with linear algebra basics

### âš™ï¸ **Programming Logic**
- [ ] Can design appropriate control structures
- [ ] Understand algorithm complexity basics
- [ ] Can implement mathematical algorithms
- [ ] Capable of systematic problem decomposition

### ğŸ† **Problem Solving**
- [ ] Can analyze problems systematically
- [ ] Choose appropriate solution strategies
- [ ] Implement and test solutions effectively
- [ ] Understand trade-offs in algorithm design

---

*ğŸš€ Next: [Advanced Algorithms and Data Structures](./1.2-Advanced-Algorithms-DataStructures.md)*
