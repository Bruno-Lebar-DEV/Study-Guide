# 🌐 3.1 FULL-STACK WEB DEVELOPMENT

> *"The modern web is not just a document delivery system—it's a platform for building the most accessible, scalable, and interactive applications in human history"*

---

## 🎯 LEARNING OBJECTIVES

By the end of this section, you will be able to:
- **🏗️ Architect complete web applications** from database to user interface
- **⚛️ Master modern frontend frameworks** (React, Vue, Angular) and their ecosystems
- **🔧 Build robust backend services** with APIs, databases, and authentication
- **🚀 Deploy and scale web applications** using modern cloud platforms
- **🔒 Implement security best practices** across the full application stack
- **📈 Optimize performance** for speed, accessibility, and user experience
- **🧪 Apply testing strategies** for both frontend and backend components

---

## 📚 1. WEB DEVELOPMENT FUNDAMENTALS

### 🌟 **The Modern Web Stack**

#### **Frontend Layer (Client-Side)**
```
┌─────────────────────────────────────────┐
│             User Interface              │
├─────────────────────────────────────────┤
│ HTML5 • CSS3 • JavaScript/TypeScript   │
│ React • Vue • Angular • Svelte         │
│ State Management • Routing • UI Libs   │
└─────────────────────────────────────────┘
```

#### **Backend Layer (Server-Side)**
```
┌─────────────────────────────────────────┐
│              API Gateway                │
├─────────────────────────────────────────┤
│  Node.js • Python • Java • Go • Rust   │
│ Express • FastAPI • Spring • Gin       │
│ Authentication • Business Logic        │
└─────────────────────────────────────────┘
```

#### **Data Layer (Persistence)**
```
┌─────────────────────────────────────────┐
│           Database Systems              │
├─────────────────────────────────────────┤
│ PostgreSQL • MongoDB • Redis • Elastic │
│ ORMs • Migrations • Caching • Search   │
└─────────────────────────────────────────┘
```

### 🔄 **Request-Response Cycle**

#### **Traditional Multi-Page Applications (MPA)**
```
Client Request → Server Processing → HTML Generation → Response
     ↑                                                    ↓
  User Action ← DOM Update ← Full Page Reload ← HTML Document
```

#### **Single Page Applications (SPA)**
```
Initial Load → JavaScript Bundle → Dynamic DOM Updates
     ↑                ↓                      ↑
API Requests ← JSON Responses ← User Interactions
```

#### **Server-Side Rendering (SSR)**
```
Client Request → Server Rendering → Pre-built HTML → Hydration
     ↑               ↓                    ↓           ↓
Interactive App ← Client JS ← DOM Ready ← Initial Content
```

---

## 🎨 2. FRONTEND DEVELOPMENT

### ⚛️ **Modern JavaScript & TypeScript**

#### **ES6+ Features**
```javascript
// Destructuring & Spread
const { name, age, ...rest } = user;
const newUser = { ...user, city: 'New York' };

// Arrow Functions & Template Literals
const greet = (name) => `Hello, ${name}!`;

// Promises & Async/Await
const fetchUserData = async (id) => {
  try {
    const response = await fetch(`/api/users/${id}`);
    return await response.json();
  } catch (error) {
    console.error('Error fetching user:', error);
  }
};

// Modules
export const UserService = {
  getUser: (id) => fetchUserData(id),
  updateUser: (id, data) => updateUserData(id, data)
};
```

#### **TypeScript Advantages**
```typescript
// Type Definitions
interface User {
  id: number;
  name: string;
  email: string;
  roles: Role[];
}

// Generic Functions
function createApiClient<T>(baseUrl: string): ApiClient<T> {
  return {
    get: (endpoint: string): Promise<T> => 
      fetch(`${baseUrl}${endpoint}`).then(res => res.json()),
    post: (endpoint: string, data: Partial<T>): Promise<T> =>
      fetch(`${baseUrl}${endpoint}`, {
        method: 'POST',
        body: JSON.stringify(data)
      }).then(res => res.json())
  };
}

// Union Types & Type Guards
type Status = 'loading' | 'success' | 'error';

function isError(status: Status): status is 'error' {
  return status === 'error';
}
```

### 🎨 **CSS Architecture & Styling**

#### **Modern CSS Features**
```css
/* CSS Custom Properties (Variables) */
:root {
  --primary-color: #3498db;
  --font-size-base: 1rem;
  --spacing-unit: 8px;
}

/* Grid Layout */
.dashboard {
  display: grid;
  grid-template-areas: 
    "header header"
    "sidebar main"
    "footer footer";
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
}

/* Flexbox for Components */
.card {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-unit);
  padding: calc(var(--spacing-unit) * 2);
}

/* Responsive Design */
@media (max-width: 768px) {
  .dashboard {
    grid-template-areas: 
      "header"
      "main"
      "sidebar"
      "footer";
    grid-template-columns: 1fr;
  }
}
```

#### **CSS-in-JS (Styled Components)**
```javascript
import styled from 'styled-components';

const Button = styled.button`
  background-color: ${props => props.primary ? '#3498db' : '#ecf0f1'};
  color: ${props => props.primary ? 'white' : '#2c3e50'};
  padding: 12px 24px;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover {
    opacity: 0.8;
    transform: translateY(-2px);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

// Usage
<Button primary onClick={handleClick}>
  Primary Action
</Button>
```

### ⚛️ **React Development**

#### **Functional Components & Hooks**
```jsx
import React, { useState, useEffect, useContext } from 'react';

// Custom Hook
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Component with Context
const UserProfile = ({ userId }) => {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);
  const { theme } = useContext(ThemeContext);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div className={`user-profile ${theme}`}>
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
};
```

#### **State Management (Redux Toolkit)**
```javascript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async Thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (params, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users');
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Slice
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    status: 'idle',
    error: null
  },
  reducers: {
    addUser: (state, action) => {
      state.items.push(action.payload);
    },
    updateUser: (state, action) => {
      const index = state.items.findIndex(user => user.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload;
      });
  }
});
```

### 🟢 **Vue.js Development**

#### **Composition API**
```vue
<template>
  <div class="todo-app">
    <input v-model="newTodo" @keyup.enter="addTodo" placeholder="Add todo...">
    <ul>
      <li v-for="todo in filteredTodos" :key="todo.id" 
          :class="{ completed: todo.completed }">
        <input type="checkbox" v-model="todo.completed">
        <span>{{ todo.text }}</span>
        <button @click="removeTodo(todo.id)">Delete</button>
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useTodos } from '@/composables/useTodos';

const { todos, addTodo, removeTodo, fetchTodos } = useTodos();
const newTodo = ref('');
const filter = ref('all');

const filteredTodos = computed(() => {
  switch (filter.value) {
    case 'active':
      return todos.value.filter(todo => !todo.completed);
    case 'completed':
      return todos.value.filter(todo => todo.completed);
    default:
      return todos.value;
  }
});

onMounted(() => {
  fetchTodos();
});
</script>
```

#### **Pinia State Management**
```javascript
import { defineStore } from 'pinia';

export const useUserStore = defineStore('user', {
  state: () => ({
    currentUser: null,
    users: [],
    loading: false
  }),

  getters: {
    isAuthenticated: (state) => !!state.currentUser,
    getUserById: (state) => (id) => 
      state.users.find(user => user.id === id)
  },

  actions: {
    async login(credentials) {
      this.loading = true;
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          body: JSON.stringify(credentials)
        });
        this.currentUser = await response.json();
      } catch (error) {
        throw error;
      } finally {
        this.loading = false;
      }
    },

    logout() {
      this.currentUser = null;
    }
  }
});
```

---

## 🔧 3. BACKEND DEVELOPMENT

### 🟢 **Node.js & Express**

#### **RESTful API Design**
```javascript
const express = require('express');
const { body, validationResult } = require('express-validator');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
app.use(express.json());

// Middleware
const authenticate = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'Access denied' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid token' });
  }
};

// Routes
app.post('/api/auth/register', [
  body('email').isEmail(),
  body('password').isLength({ min: 6 })
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { email, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const user = await User.create({
      email,
      password: hashedPassword
    });

    const token = jwt.sign(
      { userId: user.id }, 
      process.env.JWT_SECRET, 
      { expiresIn: '7d' }
    );

    res.status(201).json({ user, token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/users', authenticate, async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: ['id', 'email', 'name', 'createdAt']
    });
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

#### **GraphQL with Apollo Server**
```javascript
const { ApolloServer, gql } = require('apollo-server-express');

const typeDefs = gql`
  type User {
    id: ID!
    email: String!
    name: String
    posts: [Post!]!
  }

  type Post {
    id: ID!
    title: String!
    content: String!
    author: User!
    createdAt: String!
  }

  type Query {
    users: [User!]!
    user(id: ID!): User
    posts: [Post!]!
  }

  type Mutation {
    createUser(email: String!, name: String): User!
    createPost(title: String!, content: String!, authorId: ID!): Post!
  }
`;

const resolvers = {
  Query: {
    users: () => User.findAll(),
    user: (_, { id }) => User.findByPk(id),
    posts: () => Post.findAll()
  },

  Mutation: {
    createUser: async (_, { email, name }) => {
      return await User.create({ email, name });
    },
    createPost: async (_, { title, content, authorId }) => {
      return await Post.create({ title, content, authorId });
    }
  },

  User: {
    posts: (user) => user.getPosts()
  },

  Post: {
    author: (post) => post.getUser()
  }
};

const server = new ApolloServer({ typeDefs, resolvers });
```

### 🐍 **Python with FastAPI**

#### **Modern Python API**
```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, EmailStr
from sqlalchemy.orm import Session
from typing import List, Optional
import jwt
from datetime import datetime, timedelta

app = FastAPI(title="User Management API")
security = HTTPBearer()

# Pydantic Models
class UserCreate(BaseModel):
    email: EmailStr
    name: str
    password: str

class UserResponse(BaseModel):
    id: int
    email: str
    name: str
    created_at: datetime

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

# Dependency Injection
def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    try:
        payload = jwt.decode(
            credentials.credentials, 
            SECRET_KEY, 
            algorithms=[ALGORITHM]
        )
        user_id: int = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

# Routes
@app.post("/auth/register", response_model=Token)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    # Check if user exists
    existing_user = db.query(User).filter(User.email == user_data.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Create user
    hashed_password = get_password_hash(user_data.password)
    user = User(
        email=user_data.email,
        name=user_data.name,
        hashed_password=hashed_password
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    
    # Create token
    access_token = create_access_token(data={"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserResponse)
async def get_current_user_profile(current_user: User = Depends(get_current_user)):
    return current_user

@app.get("/users", response_model=List[UserResponse])
async def get_users(
    skip: int = 0, 
    limit: int = 100,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    users = db.query(User).offset(skip).limit(limit).all()
    return users
```

---

## 🗄️ 4. DATABASE INTEGRATION

### 🐘 **PostgreSQL with ORMs**

#### **Sequelize (Node.js)**
```javascript
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize(process.env.DATABASE_URL);

// Models
const User = sequelize.define('User', {
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: { isEmail: true }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false
  }
}, {
  hooks: {
    beforeCreate: async (user) => {
      user.password = await bcrypt.hash(user.password, 10);
    }
  }
});

const Post = sequelize.define('Post', {
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  published: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  }
});

// Associations
User.hasMany(Post, { foreignKey: 'authorId' });
Post.belongsTo(User, { foreignKey: 'authorId' });

// Complex Queries
const getUsersWithPosts = async () => {
  return await User.findAll({
    include: [{
      model: Post,
      where: { published: true },
      required: false
    }],
    order: [['createdAt', 'DESC']]
  });
};
```

#### **Prisma (Modern ORM)**
```prisma
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  password  String
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}
```

```javascript
// Using Prisma Client
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Complex queries with type safety
const getUserWithPosts = async (userId) => {
  return await prisma.user.findUnique({
    where: { id: userId },
    include: {
      posts: {
        where: { published: true },
        orderBy: { createdAt: 'desc' },
        take: 10
      }
    }
  });
};

// Transactions
const createUserWithPost = async (userData, postData) => {
  return await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({
      data: userData
    });

    const post = await tx.post.create({
      data: {
        ...postData,
        authorId: user.id
      }
    });

    return { user, post };
  });
};
```

### 🍃 **MongoDB Integration**

#### **Mongoose (Node.js)**
```javascript
const mongoose = require('mongoose');

// Schema with validation
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Invalid email']
  },
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 50
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  profile: {
    avatar: String,
    bio: String,
    location: String
  },
  settings: {
    notifications: {
      email: { type: Boolean, default: true },
      push: { type: Boolean, default: true }
    },
    privacy: {
      type: String,
      enum: ['public', 'private'],
      default: 'public'
    }
  }
}, {
  timestamps: true
});

// Middleware
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

// Methods
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Static methods
userSchema.statics.findByEmail = function(email) {
  return this.findOne({ email });
};

const User = mongoose.model('User', userSchema);

// Aggregation pipelines
const getUserStats = async () => {
  return await User.aggregate([
    {
      $group: {
        _id: '$role',
        count: { $sum: 1 },
        avgAge: { $avg: '$age' }
      }
    },
    {
      $sort: { count: -1 }
    }
  ]);
};
```

---

## 🔒 5. AUTHENTICATION & SECURITY

### 🔐 **JWT Authentication**

#### **Token-Based Authentication**
```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

class AuthService {
  static generateTokens(payload) {
    const accessToken = jwt.sign(
      payload,
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: '15m' }
    );
    
    const refreshToken = jwt.sign(
      payload,
      process.env.REFRESH_TOKEN_SECRET,
      { expiresIn: '7d' }
    );
    
    return { accessToken, refreshToken };
  }
  
  static verifyAccessToken(token) {
    try {
      return jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
    } catch (error) {
      throw new Error('Invalid access token');
    }
  }
  
  static async hashPassword(password) {
    return await bcrypt.hash(password, 12);
  }
  
  static async comparePassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  }
}

// Middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    const decoded = AuthService.verifyAccessToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};
```

### 🛡️ **Security Best Practices**

#### **Input Validation & Sanitization**
```javascript
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');

// Security middleware
app.use(helmet()); // Set security headers
app.use(mongoSanitize()); // Prevent NoSQL injection
app.use(xss()); // Clean user input from malicious HTML

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP'
});
app.use('/api/', limiter);

// Input validation
const { body, validationResult } = require('express-validator');

const validateUserInput = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Valid email required'),
  body('password')
    .isLength({ min: 8 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Password must contain uppercase, lowercase, number and special character'),
  body('name')
    .trim()
    .isLength({ min: 2, max: 50 })
    .matches(/^[a-zA-Z\s]+$/)
    .withMessage('Name must contain only letters and spaces')
];

app.post('/api/users', validateUserInput, (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  // Process valid input
});
```

#### **CORS Configuration**
```javascript
const cors = require('cors');

const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
    
    // Allow requests with no origin (mobile apps, etc.)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));
```

---

## 🚀 6. DEPLOYMENT & DEVOPS

### 🐳 **Containerization with Docker**

#### **Multi-Stage Dockerfile**
```dockerfile
# Frontend Build Stage
FROM node:18-alpine as frontend-build
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci --only=production
COPY frontend/ ./
RUN npm run build

# Backend Build Stage
FROM node:18-alpine as backend-build
WORKDIR /app/backend
COPY backend/package*.json ./
RUN npm ci --only=production
COPY backend/ ./

# Production Stage
FROM node:18-alpine as production
WORKDIR /app

# Install production dependencies
COPY backend/package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copy built frontend
COPY --from=frontend-build /app/frontend/dist ./public

# Copy backend
COPY --from=backend-build /app/backend ./

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs

EXPOSE 3000
CMD ["node", "server.js"]
```

#### **Docker Compose for Development**
```yaml
version: '3.8'

services:
  database:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: developer
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    volumes:
      - ./backend:/app
      - /app/node_modules
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://developer:password@database:5432/myapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - database
      - redis

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:3001/api
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
```

### ☁️ **Cloud Deployment**

#### **Vercel Deployment (Frontend)**
```json
{
  "name": "my-web-app",
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/public/$1"
    }
  ],
  "env": {
    "DATABASE_URL": "@database-url",
    "JWT_SECRET": "@jwt-secret"
  }
}
```

#### **AWS Deployment with Terraform**
```hcl
# main.tf
provider "aws" {
  region = "us-west-2"
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "my-web-app"
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "my-web-app-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets           = aws_subnet.public[*].id
}

# ECS Service
resource "aws_ecs_service" "app" {
  name            = "my-web-app"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 2
  launch_type     = "FARGATE"

  network_configuration {
    security_groups = [aws_security_group.app.id]
    subnets         = aws_subnet.private[*].id
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.app.arn
    container_name   = "app"
    container_port   = 3000
  }
}

# RDS Instance
resource "aws_db_instance" "main" {
  identifier             = "my-web-app-db"
  engine                = "postgres"
  engine_version        = "15.3"
  instance_class        = "db.t3.micro"
  allocated_storage     = 20
  storage_encrypted     = true
  
  db_name  = "myapp"
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  skip_final_snapshot = true
}
```

---

## 🧪 7. TESTING STRATEGIES

### 🔬 **Frontend Testing**

#### **React Testing Library**
```jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import UserProfile from './UserProfile';

// Mock API
const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(ctx.json({
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('UserProfile', () => {
  test('renders user information', async () => {
    render(<UserProfile userId={1} />);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
  });

  test('handles API error', async () => {
    server.use(
      rest.get('/api/users/:id', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );

    render(<UserProfile userId={1} />);
    
    await waitFor(() => {
      expect(screen.getByText(/error/i)).toBeInTheDocument();
    });
  });
});
```

#### **Cypress E2E Testing**
```javascript
// cypress/e2e/auth.cy.js
describe('Authentication Flow', () => {
  beforeEach(() => {
    cy.visit('/login');
  });

  it('should login successfully with valid credentials', () => {
    cy.get('[data-testid=email-input]').type('user@example.com');
    cy.get('[data-testid=password-input]').type('password123');
    cy.get('[data-testid=login-button]').click();
    
    cy.url().should('include', '/dashboard');
    cy.get('[data-testid=user-menu]').should('contain', 'Welcome');
  });

  it('should show error with invalid credentials', () => {
    cy.get('[data-testid=email-input]').type('wrong@example.com');
    cy.get('[data-testid=password-input]').type('wrongpassword');
    cy.get('[data-testid=login-button]').click();
    
    cy.get('[data-testid=error-message]')
      .should('be.visible')
      .and('contain', 'Invalid credentials');
  });

  it('should navigate through registration flow', () => {
    cy.get('[data-testid=register-link]').click();
    
    cy.get('[data-testid=name-input]').type('New User');
    cy.get('[data-testid=email-input]').type('new@example.com');
    cy.get('[data-testid=password-input]').type('newpassword123');
    cy.get('[data-testid=register-button]').click();
    
    cy.url().should('include', '/dashboard');
  });
});
```

### 🔧 **Backend Testing**

#### **Jest with Supertest**
```javascript
const request = require('supertest');
const app = require('../app');
const { User } = require('../models');

describe('Authentication API', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });

  describe('POST /api/auth/register', () => {
    test('should register a new user', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body.user).toMatchObject({
        name: userData.name,
        email: userData.email
      });
      expect(response.body.user.password).toBeUndefined();
      expect(response.body.token).toBeDefined();
    });

    test('should not register user with invalid email', async () => {
      const userData = {
        name: 'John Doe',
        email: 'invalid-email',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.errors).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            field: 'email',
            message: expect.stringContaining('valid email')
          })
        ])
      );
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: await bcrypt.hash('password123', 10)
      });
    });

    test('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'john@example.com',
          password: 'password123'
        })
        .expect(200);

      expect(response.body.user.email).toBe('john@example.com');
      expect(response.body.token).toBeDefined();
    });

    test('should not login with invalid password', async () => {
      await request(app)
        .post('/api/auth/login')
        .send({
          email: 'john@example.com',
          password: 'wrongpassword'
        })
        .expect(401);
    });
  });
});
```

---

## 📊 8. PERFORMANCE OPTIMIZATION

### ⚡ **Frontend Performance**

#### **Code Splitting & Lazy Loading**
```jsx
import { lazy, Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Lazy load components
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));
const Settings = lazy(() => import('./pages/Settings'));

// Loading component
const LoadingSpinner = () => (
  <div className="loading-spinner">
    <div className="spinner"></div>
    <p>Loading...</p>
  </div>
);

function App() {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

#### **Memoization & Optimization**
```jsx
import { memo, useMemo, useCallback, useState } from 'react';

// Memoized component
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => {
    return data.filter(item => item.active)
               .sort((a, b) => b.priority - a.priority)
               .slice(0, 100);
  }, [data]);

  return (
    <div>
      {processedData.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onUpdate={onUpdate}
        />
      ))}
    </div>
  );
});

// Parent component with optimized callbacks
const ParentComponent = () => {
  const [items, setItems] = useState([]);
  const [filter, setFilter] = useState('');

  const handleUpdate = useCallback((id, updates) => {
    setItems(prev => 
      prev.map(item => 
        item.id === id ? { ...item, ...updates } : item
      )
    );
  }, []);

  const filteredItems = useMemo(() => {
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]);

  return (
    <div>
      <input 
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Filter items..."
      />
      <ExpensiveComponent 
        data={filteredItems}
        onUpdate={handleUpdate}
      />
    </div>
  );
};
```

### 🔧 **Backend Performance**

#### **Database Query Optimization**
```javascript
// Before: N+1 Query Problem
const getBadUserPosts = async () => {
  const users = await User.findAll(); // 1 query
  
  const usersWithPosts = await Promise.all(
    users.map(async (user) => {
      const posts = await user.getPosts(); // N queries
      return { ...user.toJSON(), posts };
    })
  );
  
  return usersWithPosts;
};

// After: Optimized with Eager Loading
const getGoodUserPosts = async () => {
  return await User.findAll({
    include: [{
      model: Post,
      attributes: ['id', 'title', 'createdAt'],
      limit: 5,
      order: [['createdAt', 'DESC']]
    }],
    attributes: ['id', 'name', 'email'] // Only needed fields
  });
};

// Database indexing
const createIndexes = async () => {
  await sequelize.query(`
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_posts_author_created 
    ON posts(author_id, created_at DESC);
  `);
  
  await sequelize.query(`
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email_lower 
    ON users(LOWER(email));
  `);
};
```

#### **Caching Strategies**
```javascript
const Redis = require('redis');
const client = Redis.createClient();

class CacheService {
  static async get(key) {
    try {
      const cached = await client.get(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }
  
  static async set(key, data, ttl = 3600) {
    try {
      await client.setEx(key, ttl, JSON.stringify(data));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }
  
  static async del(key) {
    try {
      await client.del(key);
    } catch (error) {
      console.error('Cache delete error:', error);
    }
  }
  
  static cacheWrapper = (ttl = 3600) => {
    return (target, propertyName, descriptor) => {
      const method = descriptor.value;
      
      descriptor.value = async function(...args) {
        const cacheKey = `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;
        
        // Try cache first
        const cached = await CacheService.get(cacheKey);
        if (cached) return cached;
        
        // Execute method and cache result
        const result = await method.apply(this, args);
        await CacheService.set(cacheKey, result, ttl);
        
        return result;
      };
    };
  };
}

// Usage with decorator
class UserService {
  @CacheService.cacheWrapper(1800) // 30 minutes
  static async getUserProfile(userId) {
    return await User.findByPk(userId, {
      include: [{ model: Post, limit: 10 }]
    });
  }
  
  static async updateUser(userId, data) {
    const user = await User.update(data, { where: { id: userId } });
    
    // Invalidate cache
    await CacheService.del(`UserService:getUserProfile:["${userId}"]`);
    
    return user;
  }
}
```

---

## 🎯 9. PRACTICAL PROJECTS

### 🚀 **Project 1: Task Management Application**

#### **Requirements**
- User authentication and authorization
- CRUD operations for tasks and projects
- Real-time updates with WebSockets
- File attachments and comments
- Email notifications
- Mobile-responsive design

#### **Technology Stack**
```
Frontend: React + TypeScript + Tailwind CSS
Backend: Node.js + Express + Socket.io
Database: PostgreSQL + Redis
Deployment: Docker + AWS ECS
```

#### **Implementation Highlights**
```jsx
// Real-time task updates
const useTaskUpdates = (projectId) => {
  const [tasks, setTasks] = useState([]);
  const socket = useSocket();

  useEffect(() => {
    socket.emit('join_project', projectId);
    
    socket.on('task_created', (task) => {
      setTasks(prev => [...prev, task]);
    });
    
    socket.on('task_updated', (updatedTask) => {
      setTasks(prev => 
        prev.map(task => 
          task.id === updatedTask.id ? updatedTask : task
        )
      );
    });
    
    return () => {
      socket.emit('leave_project', projectId);
      socket.off('task_created');
      socket.off('task_updated');
    };
  }, [projectId, socket]);

  return tasks;
};
```

### 📊 **Project 2: E-commerce Platform**

#### **Features**
- Product catalog with search and filtering
- Shopping cart and checkout process
- Payment integration (Stripe/PayPal)
- Order management and tracking
- Admin dashboard for inventory
- Customer reviews and ratings

#### **Advanced Implementation**
```javascript
// Payment processing with Stripe
const processPayment = async (req, res) => {
  try {
    const { amount, currency, paymentMethodId, orderId } = req.body;
    
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amount * 100, // Convert to cents
      currency,
      payment_method: paymentMethodId,
      confirmation_method: 'manual',
      confirm: true,
      metadata: { orderId }
    });
    
    if (paymentIntent.status === 'succeeded') {
      await Order.update(
        { status: 'paid', paymentIntentId: paymentIntent.id },
        { where: { id: orderId } }
      );
      
      // Send confirmation email
      await EmailService.sendOrderConfirmation(orderId);
    }
    
    res.json({ success: true, paymentIntent });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};
```

### 🎮 **Project 3: Real-time Chat Application**

#### **Features**
- Multiple chat rooms
- Private messaging
- File sharing
- Message history and search
- Online presence indicators
- Mobile push notifications

#### **WebSocket Implementation**
```javascript
// Socket.io server setup
const io = require('socket.io')(server, {
  cors: { origin: process.env.CLIENT_URL }
});

io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findByPk(decoded.userId);
    socket.user = user;
    next();
  } catch (error) {
    next(new Error('Authentication error'));
  }
});

io.on('connection', (socket) => {
  console.log(`User ${socket.user.name} connected`);
  
  socket.on('join_room', async (roomId) => {
    await socket.join(roomId);
    socket.to(roomId).emit('user_joined', {
      userId: socket.user.id,
      name: socket.user.name
    });
  });
  
  socket.on('send_message', async (data) => {
    const message = await Message.create({
      content: data.content,
      roomId: data.roomId,
      userId: socket.user.id
    });
    
    io.to(data.roomId).emit('new_message', {
      ...message.toJSON(),
      user: socket.user
    });
  });
  
  socket.on('disconnect', () => {
    console.log(`User ${socket.user.name} disconnected`);
  });
});
```

---

## 📚 10. SELF-ASSESSMENT CHECKLIST

### ✅ **Frontend Development Mastery**
- [ ] Can build responsive layouts with modern CSS (Grid, Flexbox)
- [ ] Proficient in ES6+ JavaScript and TypeScript
- [ ] Experienced with at least one major framework (React/Vue/Angular)
- [ ] Understands state management patterns and libraries
- [ ] Can implement client-side routing and navigation
- [ ] Knows how to optimize bundle size and performance
- [ ] Familiar with testing methodologies (unit, integration, e2e)
- [ ] Can handle forms, validation, and user input
- [ ] Understands accessibility (a11y) best practices
- [ ] Experienced with build tools and development workflows

### ✅ **Backend Development Mastery**
- [ ] Can design and implement RESTful APIs
- [ ] Understands database design and optimization
- [ ] Experienced with authentication and authorization
- [ ] Knows how to handle file uploads and processing
- [ ] Can implement real-time features (WebSockets)
- [ ] Familiar with caching strategies and implementation
- [ ] Understands security best practices and vulnerabilities
- [ ] Can write comprehensive tests for APIs
- [ ] Experienced with background jobs and queues
- [ ] Knows how to monitor and debug production applications

### ✅ **Full-Stack Integration**
- [ ] Can architect complete applications from scratch
- [ ] Understands the complete request-response cycle
- [ ] Experienced with deployment and DevOps practices
- [ ] Can integrate third-party services and APIs
- [ ] Knows how to handle errors and edge cases
- [ ] Familiar with performance monitoring and optimization
- [ ] Can implement CI/CD pipelines
- [ ] Understands scaling strategies and patterns
- [ ] Experienced with version control and collaboration
- [ ] Can mentor others and lead technical decisions

---

## 🔗 ADDITIONAL RESOURCES

### 📚 **Essential Books**
- **"Eloquent JavaScript"** by Marijn Haverbeke
- **"You Don't Know JS"** series by Kyle Simpson
- **"Fullstack React"** by Anthony Accomazzo
- **"Node.js Design Patterns"** by Mario Casciaro
- **"Designing Data-Intensive Applications"** by Martin Kleppmann

### 🎥 **Video Courses**
- **"The Complete Web Developer Course"** by Rob Percival
- **"React - The Complete Guide"** by Maximilian Schwarzmüller
- **"The Complete Node.js Developer Course"** by Andrew Mead
- **"Modern JavaScript From The Beginning"** by Brad Traversy

### 🌐 **Online Platforms**
- **freeCodeCamp:** Comprehensive curriculum with projects
- **The Odin Project:** Full-stack development roadmap
- **Frontend Mentor:** Real-world design challenges
- **Backend Challenges:** API development practice

### 🛠️ **Tools & Resources**
- **MDN Web Docs:** Authoritative web development documentation
- **Can I Use:** Browser compatibility tables
- **React DevTools:** Browser extension for React debugging
- **Postman:** API development and testing platform

---

*🎯 Remember: Full-stack development is about understanding the entire application ecosystem. Master the fundamentals, practice consistently, and always consider the user experience from database to browser.*
